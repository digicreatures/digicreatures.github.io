<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>digiCreatures - articles</title><link href="http://digicreatures.net/" rel="alternate"></link><link href="http://digicreatures.net/feeds/articles.atom.xml" rel="self"></link><id>http://digicreatures.net/</id><updated>2021-11-30T00:00:00+01:00</updated><entry><title>Rigacar</title><link href="http://digicreatures.net/articles/rigacar.html" rel="alternate"></link><published>2018-08-10T12:00:00+02:00</published><updated>2021-11-30T00:00:00+01:00</updated><author><name>David Gayerie</name></author><id>tag:digicreatures.net,2018-08-10:/articles/rigacar.html</id><summary type="html">&lt;p class="first last"&gt;a Blender add-on to rig... a car&lt;/p&gt;
</summary><content type="html">&lt;div class="admonition admonition-downloadable-file"&gt;
&lt;p class="first admonition-title"&gt;Downloadable file&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/digicreatures/rigacar/releases/latest"&gt;rigacar.zip&lt;/a&gt;&lt;/p&gt;
&lt;p class="last"&gt;This add-on is available for free on GitHub for &lt;strong&gt;Blender 3.0, 2.9X and 2.83&lt;/strong&gt;. For previous
versions, go and check the &lt;a class="reference external" href="https://github.com/digicreatures/rigacar/releases"&gt;releases page&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;If you want to animate cars but you don't want to spend too much time for rigging,
Rigacar could be helpful. It is a free add-on for &lt;a class="reference external" href="https://www.blender.org"&gt;Blender&lt;/a&gt; I developed for one of
my projects. Rigacar was designed to fulfill the following goals:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;generate a complete rig as quickly as possible for &lt;em&gt;standard&lt;/em&gt; car models&lt;/li&gt;
&lt;li&gt;provide tools to automate wheels animation&lt;/li&gt;
&lt;li&gt;allow efficient animation baking to be able to export animated models into real time renderers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the end of this documentation, there is a section dedicated to useful &lt;a class="reference internal" href="#advices"&gt;advices&lt;/a&gt; to
create animations and avoid common mistakes.&lt;/p&gt;
&lt;p&gt;Before reading this documentation, you can watch my &lt;a class="reference external" href="https://www.youtube.com/playlist?list=PLH_mmrv8SfPFiEj93RJt3sBvHCnipI9qK"&gt;series of videotutorials&lt;/a&gt;:&lt;/p&gt;
&lt;div class="images docutils container"&gt;
&lt;div class="youtube youtube-16x9"&gt;&lt;iframe src="https://www.youtube.com/embed/D3XQxA_-TzY" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div class="youtube youtube-16x9"&gt;&lt;iframe src="https://www.youtube.com/embed/2GRy5A-MQQk" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div class="youtube youtube-16x9"&gt;&lt;iframe src="https://www.youtube.com/embed/MN6CXG83Wdw" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div class="youtube youtube-16x9"&gt;&lt;iframe src="https://www.youtube.com/embed/KzioiEyQ8F4" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div class="youtube youtube-16x9"&gt;&lt;iframe src="https://www.youtube.com/embed/-ZJMoQ3KpLM" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class="admonition caution"&gt;
&lt;p class="first admonition-title"&gt;Caution!&lt;/p&gt;
&lt;p&gt;These videotutorials are based on a previous version of the add-on for Blender
2.7x and are therefore a little bit outdated. But they should still be helpful.
Below is a list of things explained in the videos which &lt;strong&gt;are no more relevant&lt;/strong&gt;:&lt;/p&gt;
&lt;dl class="last docutils"&gt;
&lt;dt&gt;Part 1: adding a new rig&lt;/dt&gt;
&lt;dd&gt;I explain in this video you need to adjust the length of the body bone when you
add the armature to indicate the length of your model. This is no longer necessary.
Rigacar computes bounding boxes for each reference object and their children
to discover the dimension of your model. Naming convention to match objects
of your model with the main parts of the rig is now case insensitive.&lt;/dd&gt;
&lt;dt&gt;Part 2: adjusting the rig&lt;/dt&gt;
&lt;dd&gt;Adjusting widgets could still be necessary but Rigacar is now able to
place widgets at a fair location.&lt;/dd&gt;
&lt;dt&gt;Part 3: animating along path&lt;/dt&gt;
&lt;dd&gt;No need to adjust the delta location of your armature after adding a follow
path constraint. Origin point of the armature is adjusted automatically at
generation time.&lt;/dd&gt;
&lt;dt&gt;Part 4: slamming on brakes&lt;/dt&gt;
&lt;dd&gt;Brakes have their own animation widgets now.&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="prepare-your-model"&gt;
&lt;h2&gt;Prepare your model&lt;/h2&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/model.jpg" data-lightbox="rigacar"&gt;&lt;img alt="BMW 27 model" src="http://digicreatures.net/photos/rigacar/modelt.jpg" /&gt;&lt;/a&gt;
&lt;div class="admonition admonition-downloadable-file"&gt;
&lt;p class="first admonition-title"&gt;Downloadable file&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://digicreatures.net/resources/rigacar/bmw27_with_rig.blend"&gt;bmw27_with_rig.blend&lt;/a&gt;&lt;/p&gt;
&lt;p class="last"&gt;You can download the blend file with the model and the complete rig. Don't
forget to download and install &lt;a class="reference external" href="https://github.com/digicreatures/rigacar/releases/latest"&gt;Rigacar&lt;/a&gt;.
Nice BMW27 model used in this article is a modified version of the one available in the
&lt;a class="reference external" href="https://www.blender.org/download/demo-files/"&gt;Blender demo files&lt;/a&gt;.
Thanks to Mike Pan for creating and sharing it.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Rigacar expects your model is oriented along the -Y axis and the wheels lay
upon the grid floor. This way, the front of your model matches the front view in
&lt;a class="reference external" href="https://www.blender.org"&gt;Blender&lt;/a&gt;. If it is not the case, you should rotate your model to match this orientation.
Of course, don't forget to apply rotation and scale on your model.&lt;/p&gt;
&lt;p&gt;Once you have installed and enabled the add-on, you should follow these steps:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;prepare your model and ensure you have followed the naming convention to let the
add-on discover the structure of your model&lt;/li&gt;
&lt;li&gt;add the deformation rig&lt;/li&gt;
&lt;li&gt;generate the final animation rig&lt;/li&gt;
&lt;li&gt;tweak the rig and, optionally, extend the rig for your own purposes&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="use-naming-convention-for-reference-objects"&gt;
&lt;h3&gt;Use naming convention for reference objects&lt;/h3&gt;
&lt;p&gt;Before adding the rig to your scene, I highly recommend to adjust your model and to follow
a naming convention for each part. This way, Rigacar will be able to analyse your model
and to create an accurate deformation rig.&lt;/p&gt;
&lt;p&gt;Rigacar is able to identify &lt;em&gt;reference objects&lt;/em&gt; based on their names. Reference
objects are objects used for the body, the wheels and the brake wheels in your model.
The &lt;strong&gt;name for these reference objects should be suffixed&lt;/strong&gt; according to the
rules describe in the following table:&lt;/p&gt;
&lt;table border="1" class="colwidths-given docutils"&gt;
&lt;colgroup&gt;
&lt;col width="20%" /&gt;
&lt;col width="40%" /&gt;
&lt;col width="40%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Suffix&lt;/th&gt;
&lt;th class="head"&gt;Part of the model&lt;/th&gt;
&lt;th class="head"&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;body&lt;/td&gt;
&lt;td&gt;The Body of the model&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-body&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheel.Ft.L&lt;/td&gt;
&lt;td&gt;The front left wheel&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheel.Ft.L&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheel.Ft.R&lt;/td&gt;
&lt;td&gt;The front right wheel&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheel.Ft.R&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheel.Bk.L&lt;/td&gt;
&lt;td&gt;The rear left wheel&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheel.Bk.L&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheel.Bk.R&lt;/td&gt;
&lt;td&gt;The rear right wheel&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheel.Bk.R&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheelbrake.Ft.L&lt;/td&gt;
&lt;td&gt;The front left brake wheel or any part associated with the wheel which does not spin&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheelbrake.Ft.L&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheelbrake.Ft.R&lt;/td&gt;
&lt;td&gt;The front right brake wheel or any part associated with the wheel which does not spin&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheelbrake.Ft.R&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheelbrake.Bk.L&lt;/td&gt;
&lt;td&gt;The rear left brake wheel or any part associated with the wheel which does not spin&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheelbrake.Bk.L&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;wheelbrake.Bk.R&lt;/td&gt;
&lt;td&gt;The rear right brake wheel or any part associated with the wheel which does not spin&lt;/td&gt;
&lt;td&gt;&lt;em&gt;mycar-wheelbrake.Bk.R&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Name matching is case insensitive and you can use dot, space, dash or underscore
as separators. Following names are all valid: &lt;em&gt;mycar.Wheel.Ft.L&lt;/em&gt;, &lt;em&gt;mycar-wheel-Ft-L&lt;/em&gt;,
&lt;em&gt;mycar wheel fr l&lt;/em&gt;, &lt;em&gt;mycar_WHEEL_FT_L&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You may have multiple objects for each part. For instance you may have one
object for the wheel rim and another for the tire. Consider one of these as
the reference object and name it according to the convention.
Then parent the others to this one. See below as an example, the outliner for
the scene used in this article:&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/outliner_objects_hierarchy.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Objects hierarchy in the outliner" src="http://digicreatures.net/photos/rigacar/outliner_objects_hierarchyt.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;If your model has more than one pair of wheels at front or at rear, use the same
convention as Blender: add a number with 3 digits at the end: &lt;em&gt;mycar-Wheel.Ft.L.001&lt;/em&gt;,
&lt;em&gt;mycar-Wheel.Ft.R.001&lt;/em&gt;, &lt;em&gt;mycar-Wheel.Ft.L.002&lt;/em&gt;, &lt;em&gt;mycar-Wheel.Ft.R.002&lt;/em&gt;...&lt;/p&gt;
&lt;p&gt;If some of these objects do not exist, Rigacar will adjust the rig. For instance,
you can create a valid rig for models with no brake wheel. You
can even use Rigacar for models without any front wheel or back wheel (or even
no wheel at all... even if I doubt your model should be some sort of car).&lt;/p&gt;
&lt;div class="admonition caution"&gt;
&lt;p class="first admonition-title"&gt;Caution!&lt;/p&gt;
&lt;p class="last"&gt;&lt;strong&gt;Known limitation: do not parent your reference objects (body, wheels,
wheel brakes) to anything before adding the rig&lt;/strong&gt;. It could generate errors
or an incorrect rig.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="check-origins"&gt;
&lt;h3&gt;Check origins&lt;/h3&gt;
&lt;p&gt;Rigacar will use the origin point of each reference objects to locate the generated
bones. Before adding the deformation rig (see the next section), you should check
the origin of each of them:&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Reference object for the body&lt;/dt&gt;
&lt;dd&gt;The origin indicates the location around which the model will pitch and roll.&lt;/dd&gt;
&lt;dt&gt;Reference object for the wheel&lt;/dt&gt;
&lt;dd&gt;The origin indicates the center of the wheel which is the intersection of the
spinning axis and the steering axis (only for front wheels)&lt;/dd&gt;
&lt;dt&gt;Reference object for the brake wheel&lt;/dt&gt;
&lt;dd&gt;The origin should be the point of the attachment of the brake wheel. You should
align it with the origin of the wheel.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;In the model below, you see the origin point and the name of each reference objects:&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/reference_objects.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Emphasizing reference objects for each part of the model" src="http://digicreatures.net/photos/rigacar/reference_objectst.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;In the previous image, reference object for the body is yellow, reference objects
for wheels are red and reference objects for brakes are green. All other objects
are white and are parented to one reference object.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="add-the-deformation-rig"&gt;
&lt;h2&gt;Add the deformation rig&lt;/h2&gt;
&lt;p&gt;Once you have installed the add-on, you can add a new kind of armature in your
scene: a &lt;strong&gt;car deformation rig&lt;/strong&gt;. It is an armature with only bones
used to animate directly your model: the body, the wheels and the brakes.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/add_menu.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Add menu to create a new car deformation rig" src="http://digicreatures.net/photos/rigacar/add_menut.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;When you add such an armature, Rigacar will try to discover reference objects
amongst the selected objects. For each one found, Rigacar will automatically position
the associated bones at the same origin point and will parent the reference object
to the bone.&lt;/p&gt;
&lt;p&gt;So the rule of thumb is: &lt;strong&gt;select all the objects of your model, add the rig and
let the add-on do the job for you&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;If needed, you can use the operator panel to tweak the deformation rig:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;add front/back wheel pairs. You can even remove front wheels or back wheels&lt;/li&gt;
&lt;li&gt;add bones for brakes&lt;/li&gt;
&lt;li&gt;adjust location of bones&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have correctly prepared your model, you should not have to tweak the
deformation rig. If the rig seems not correct, it could be difficult to tweak
it by hand. Consider checking the name and origin point of your objects then
add the rig again. Most of the time, it's just about using an iterative process.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/deformation_rig_operator_panel.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Operator parameters panel when adding a car deformation rig" class="last" src="http://digicreatures.net/photos/rigacar/deformation_rig_operator_panelt.jpg" /&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;Each generated bone is named following the same convention as the reference
objects:&lt;/p&gt;
&lt;table border="1" class="colwidths-given docutils"&gt;
&lt;colgroup&gt;
&lt;col width="38%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;DEF-Body&lt;/td&gt;
&lt;td&gt;Deformation bone for the body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-Wheel.Ft.L&lt;/td&gt;
&lt;td&gt;Deformation bone for the front left wheel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-Wheel.Ft.R&lt;/td&gt;
&lt;td&gt;Deformation bone for the front right wheel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-Wheel.Bk.L&lt;/td&gt;
&lt;td&gt;Deformation bone for the rear left wheel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-Wheel.Bk.R&lt;/td&gt;
&lt;td&gt;Deformation bone for the rear right wheel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-WheelBrake.Ft.L&lt;/td&gt;
&lt;td&gt;Deformation bone for the front left brake&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-WheelBrake.Ft.R&lt;/td&gt;
&lt;td&gt;Deformation bone for the front right brake&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-WheelBrake.Bk.L&lt;/td&gt;
&lt;td&gt;Deformation bone for the rear left brake&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEF-WheelBrake.Bk.R&lt;/td&gt;
&lt;td&gt;Deformation bone for the rear right brake&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If your model has more than one front or back pair of wheels, additional
bones will have name suffixed by a number: DEF-Wheel.Ft.L.001 or
DEF-Wheel.Ft.R.001 for instance.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/deformation_rig_with_bonesname.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Name of the deformation bones generated" src="http://digicreatures.net/photos/rigacar/deformation_rig_with_bonesnamet.jpg" /&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="generate-the-complete-rig"&gt;
&lt;h2&gt;Generate the complete rig&lt;/h2&gt;
&lt;p&gt;Once the deformation rig is added, you can now generate the complete rig.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/generate_animation_rig.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Generate the final rig" src="http://digicreatures.net/photos/rigacar/generate_animation_rigt.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Use the button &lt;tt class="docutils literal"&gt;Generate&lt;/tt&gt; available in the properties panel in the 3D View. You can
also find the same button in the properties of the armature.&lt;/p&gt;
&lt;p&gt;The complete rig is generated and the animation widgets are dispatched over
several armature's layers:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Layer 1 (blue widgets) contains the root widget for the overall model and
the drift widget to control location and orientation of the car&lt;/li&gt;
&lt;li&gt;Layer 2 (yellow widgets) contains the suspension widget and one damper widget per wheel&lt;/li&gt;
&lt;li&gt;Layer 3 (green widgets) contains widgets for front wheels, back wheels, brakes and steering&lt;/li&gt;
&lt;li&gt;Layer 4 (red widgets) contains the ground sensors (one per wheel and one per axle)&lt;/li&gt;
&lt;li&gt;layer 14 contains bones necessary to tweak the position of the widgets&lt;/li&gt;
&lt;li&gt;layer 15 contains main mechanical bones (useful to extend the rig)&lt;/li&gt;
&lt;li&gt;Layer 16 contains deformation bones (those originally added by the deformation rig)&lt;/li&gt;
&lt;li&gt;Layer 32 contains all mechanical bones (no need to have a look at it).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Layers 1, 2, 3 and 4 are useful for animators. Layer 14 is useful for riggers
to tweak the generated rig (see below). Layer 15 is useful for riggers
who want to extend the rig with more bones. For instance, if you want to add bones
to control side doors, you should parent these new bones to &lt;em&gt;MCH-Body&lt;/em&gt; from this layer.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/animation_rig.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Side view and top view of the generated rig" src="http://digicreatures.net/photos/rigacar/animation_rigt.jpg" /&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="tweak-the-generated-rig"&gt;
&lt;h2&gt;Tweak the generated rig&lt;/h2&gt;
&lt;p&gt;Once you have generated the animation rig, you may need to tweak it.&lt;/p&gt;
&lt;div class="section" id="check-the-spinning-of-the-wheels"&gt;
&lt;h3&gt;Check the spinning of the wheels&lt;/h3&gt;
&lt;p&gt;The animation rig can rotate wheels as you move your model along the Y axis.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/rigacar_panel_wheels_on_y_axis.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Activating the rotation of the wheels for motion along the Y axis" src="http://digicreatures.net/photos/rigacar/rigacar_panel_wheels_on_y_axist.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Be aware the spinning is only correct for translation on the Y axis.
So, this feature is not the proper way to animate wheels with Rigacar (see section
below). But it is useful to quickly check the generated rig. In the properties panel,
put the property &lt;tt class="docutils literal"&gt;Wheels on Y axis&lt;/tt&gt; to 1 to activate this feature. Don't forget
to set it back to 0 once you have checked your model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="adjust-widgets-location"&gt;
&lt;h3&gt;Adjust widgets' location&lt;/h3&gt;
&lt;p&gt;Rigacar will try to position widgets to match your model. But you can adjust
position of widgets and scale them at your ease.&lt;/p&gt;
&lt;p&gt;To adjust position of widgets, go the layer 14 of the armature.
This layer displays bones useful to tweak position of the widgets. Even if
the rig seems to be displayed as usual, the bones are not quite the same. For instance,
if you select the widget for the root bone, you will in fact select a bone named
&lt;em&gt;SHP-Root&lt;/em&gt;. If you are not familiar with creating custom shapes for bones in Blender,
the good news is you don't need to fully understand the technical stuff.
Just go to layer 14, select the widget you want to move, go to edit mode
and change the position of the selected bone and it will update the position of the widget.&lt;/p&gt;
&lt;p&gt;To scale up/down a widget, you have to go back to layers 1 to 4, go to pose mode
and change the scale of the custom widget from properties panel for the bone.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="edit-properties-for-ground-sensors"&gt;
&lt;h3&gt;Edit properties for ground sensors&lt;/h3&gt;
&lt;p&gt;Ground sensors (layer 4) are widgets generated for each wheel and for each axle. They
are used to make sure your model will follow the ground of your scene. They are
bones generated with a &lt;a class="reference external" href="https://docs.blender.org/manual/en/latest/rigging/constraints/relationship/shrinkwrap.html"&gt;shrinkwrap constraint&lt;/a&gt; named &lt;em&gt;Ground projection&lt;/em&gt;.
This constraint is not activated by default. You can tweak each ground sensor
from a dedicated section in the properties panel. You can pick the object
for the ground and adjust min/max local Z values to limit wheels vertical
position to avoid inaccurate positions (like passing through the body).
You can also pick the object in your scene which is the ground.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/animation_rig_ground_constraint_properties.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Properties panel for ground sensors" src="http://digicreatures.net/photos/rigacar/animation_rig_ground_constraint_propertiest.jpg" /&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="adjust-suspension"&gt;
&lt;h3&gt;Adjust suspension&lt;/h3&gt;
&lt;p&gt;Moving ground sensor and damper widgets has an effect on the body of your model.
Animation of these widgets is supposed to be subtle. Otherwise, your model
will be stripped away. If you want, you can adjust this suspension effect in
the &lt;em&gt;Animation Rig&lt;/em&gt; panel.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/rigacar_panel_suspension.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Properties panel for pitch factor and roll factor" src="http://digicreatures.net/photos/rigacar/rigacar_panel_suspensiont.jpg" /&gt;&lt;/a&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Pitch factor&lt;/dt&gt;
&lt;dd&gt;This factor adjusts the variation on the local Z axis of the body when ground
sensors and/or damper widgets are moving.&lt;/dd&gt;
&lt;dt&gt;Roll factor&lt;/dt&gt;
&lt;dd&gt;This factor adjusts rolling of the body on the local Y axis when ground sensors
and/or damper widgets are moving.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;If you want to keep full control on your animation, you can turn these factors
to 0 to deactivate any effect from the suspension.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="add-widgets-for-brake"&gt;
&lt;h3&gt;Add widgets for brake&lt;/h3&gt;
&lt;p&gt;By default, Rigacar generates one widget for brake at the front and one at
the rear. These widgets can be scale in/out to simulate the effect of brakes.
Rigacar will take them into account for generating the spinning of wheels
(see next section).&lt;/p&gt;
&lt;p&gt;You may need to have more widgets for brakes if you want to animate wheels
independently. To add more widgets in pose mode, select the wheel widget to
indicate which wheel must have its own brake widget. Search for the operator
named &lt;tt class="docutils literal"&gt;Add missing brake wheel bones&lt;/tt&gt; by pressing &lt;tt class="docutils literal"&gt;F3&lt;/tt&gt; (search mode since
Blender 2.8x).Then press &lt;tt class="docutils literal"&gt;Enter&lt;/tt&gt; and the additional widget will be added.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/add_brake.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Searching the operator for adding missing brake" src="http://digicreatures.net/photos/rigacar/add_braket.jpg" /&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bake-wheels-animation"&gt;
&lt;h2&gt;Bake wheels animation&lt;/h2&gt;
&lt;p&gt;Most of the time, you don't really need to animate wheels. Rigacar can bake the
animation for you based on the motion of your model. So you should not animate
the steering widget nor widget for wheels but use buttons to bake their animation.&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/rigacar_panel_bake.jpg" data-lightbox="rigacar"&gt;&lt;img alt="The bake panel" src="http://digicreatures.net/photos/rigacar/rigacar_panel_baket.jpg" /&gt;&lt;/a&gt;
&lt;div class="section" id="bake-steering"&gt;
&lt;h3&gt;Bake steering&lt;/h3&gt;
&lt;p&gt;The button &lt;tt class="docutils literal"&gt;Bake car steering&lt;/tt&gt; computes animation of the steering. When you click
on it, a popup dialog is displayed to adjust baking parameters:&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/rigacar_panel_bake_steering.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Parameters panel for bake car steering" src="http://digicreatures.net/photos/rigacar/rigacar_panel_bake_steeringt.jpg" /&gt;&lt;/a&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Start frame and end frame&lt;/dt&gt;
&lt;dd&gt;The range for the animation. By default it matches the range of the current
animation. You can adjust it if you like.&lt;/dd&gt;
&lt;dt&gt;Rotation factor&lt;/dt&gt;
&lt;dd&gt;The value is used as a factor to adjust strength of the steering. If you want
to create animation with a more noticeable animation of the steering, you can
use a higher value.&lt;/dd&gt;
&lt;dt&gt;Keyframe tolerance&lt;/dt&gt;
&lt;dd&gt;Rigacar can try not to add keyframe if it is not necessary. If you want to remove
some noise in the animation, you can crank up this value: Rigacar will become
more and more tolerant and will ignore significant variations, adding less
keyframes. On the contrary, if you set this value to zero, Rigacar will
add keyframes for each frame.
&lt;strong&gt;You should not have to modify this parameter. Try tweaking it only if you
get some weird result.&lt;/strong&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="bake-wheels-rotation"&gt;
&lt;h3&gt;Bake wheels rotation&lt;/h3&gt;
&lt;p&gt;The button &lt;tt class="docutils literal"&gt;Bake wheels rotation&lt;/tt&gt; computes spinning of the wheels. Rigacar
takes into account the brake widgets to animate the wheels. When you click
on it, a popup dialog is displayed to adjust baking parameters:&lt;/p&gt;
&lt;a href="http://digicreatures.net/photos/rigacar/rigacar_panel_bake_wheels_rotation.jpg" data-lightbox="rigacar"&gt;&lt;img alt="Parameters panel for bake wheels rotation" src="http://digicreatures.net/photos/rigacar/rigacar_panel_bake_wheels_rotationt.jpg" /&gt;&lt;/a&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Start frame and end frame&lt;/dt&gt;
&lt;dd&gt;The range for the animation. By default it matches the range of the current
animation. You can adjust it if you like.&lt;/dd&gt;
&lt;dt&gt;Keyframe tolerance&lt;/dt&gt;
&lt;dd&gt;Rigacar can try not to add keyframe if it is not necessary. If you want to remove
some noise in the animation, you can crank up this value: Rigacar will become
more and more tolerant and will ignore significant variations, adding less
keyframes. On the contrary, if you set this value to zero, Rigacar will
add keyframes for each frame.
&lt;strong&gt;You should not have to modify this parameter. Try tweaking it only if you
get some weird result.&lt;/strong&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;If you want to animate skidding during braking, you can activate brakes on wheels. Scale
down brake widgets, add keyframes then hit &lt;tt class="docutils literal"&gt;Bake wheels rotation&lt;/tt&gt; again.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-baked-animation"&gt;
&lt;h3&gt;Clear baked animation&lt;/h3&gt;
&lt;p&gt;Sometime, you want to remove animations generated by Rigacar for steering and
wheels. In this case, click on the button &lt;tt class="docutils literal"&gt;Clear baked animation&lt;/tt&gt;. This will reset
bones rotation and remove generated keyframes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="advices-and-reminders"&gt;
&lt;span id="advices"&gt;&lt;/span&gt;&lt;h2&gt;Advices and reminders&lt;/h2&gt;
&lt;p&gt;Based on many feedbacks and comments, I added this section to share tips for
avoiding common mistakes and creating better animations.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Rigacar is no car simulator&lt;/strong&gt;. Don't expect to see you model drift or any
kind of nice things happens automatically. Sorry, It's just a rig generator.
you have to do the animation yourself. At least, it provides a quick and easy
way to generate keyframes for wheels animation. Probably could do much more
but not at the current state...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Unfortunately Rigacar is not able to rig three-wheeled vehicle or bike&lt;/strong&gt;.
It is designed for vehicles with one or more pairs of wheels. Anyway, Jamis
made a tutorial to rig a three-wheeled car with Rigacar (many thanks to him):&lt;/p&gt;
&lt;div class="youtube youtube-16x9"&gt;&lt;iframe src="https://www.youtube.com/embed/vnp84KZnpnk" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;This tutorial could be useful but the generated rig is not 100% efficient
(there are some issues with suspension). But if it is good enough for you
who cares it is not 100% efficient.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Do not add a new rig in a non editable collection&lt;/strong&gt;, it will not work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The easiest way to animate your model is by making it following a curve object.
You can use &lt;tt class="docutils literal"&gt;follow path&lt;/tt&gt; constraint &lt;strong&gt;on the root widget as a bone
constraint&lt;/strong&gt; in pose mode (take care not adding the constraint on the armature
itself).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;With &lt;tt class="docutils literal"&gt;follow path&lt;/tt&gt; constraint, checked the option &lt;tt class="docutils literal"&gt;Follow curve&lt;/tt&gt; and use
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-Y&lt;/span&gt;&lt;/tt&gt; for the forward direction because your model is supposed to be aligned
along -Y axis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;If you use a curve as a path for your model, &lt;strong&gt;do not use the default value of&lt;/strong&gt;
&lt;tt class="docutils literal"&gt;Resolution preview U&lt;/tt&gt; &lt;strong&gt;for the curve&lt;/strong&gt; (a value of 100 is generally fine).
Even if the curve seems smooth on screen, it could create jagged animation
because curves are only sampling of points. &lt;tt class="docutils literal"&gt;Resolution preview U&lt;/tt&gt; defines
the resolution of your curve and is available in the &lt;tt class="docutils literal"&gt;Object Data Properties&lt;/tt&gt;
panel.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;When you use ground sensors, make sure you &lt;strong&gt;apply scale on the mesh object
used as the ground&lt;/strong&gt; in your scene. Otherwise, you may ended up with a model
floating above the ground.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;After baking animation for wheels, it could seem the wheels are not
spinning in the right direction (going backward while the model is going forward)
or the wheels are barely spinning. You can check the generated animation
curves in the graph editor but &lt;strong&gt;it is more likely an optical effect.&lt;/strong&gt; It
happens in movie, it happens in life and it happens in Blender. To know more,
&lt;a class="reference external" href="https://io9.gizmodo.com/why-do-wheels-sometimes-appear-to-spin-backwards-1593807400"&gt;read this article&lt;/a&gt;.
Try using motion blur at render time to have a more realistic effect.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;If you want your model to go forward and backward in the same scene (in a car
park animation for instance), the best method I know is to use multiple curves.
Obviously, the last control point of one curve must be at the same location as
the first control point of the next curve. But to achieve a smooth animation,
&lt;strong&gt;the second-last control point of one curve must be at the same location as
the second control point of the next curve.&lt;/strong&gt; You have to animate the motion
of the root widget along these curves using several &lt;tt class="docutils literal"&gt;Follow path&lt;/tt&gt; constraints.
You also have to animate activation and deactivation of these constraints along
the timeline.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="to-infinity-and-beyond"&gt;
&lt;h2&gt;To infinity and beyond&lt;/h2&gt;
&lt;p&gt;I would be glad if this add-on could be useful to some of you. I am no professional
rigger nor animator. So I am pretty sure this add-on and the generated rig can
be dramatically improved. Use them in a way I have not imagined and give me feedbacks.
You can use the comments below, you can &lt;a class="reference external" href="https://github.com/digicreatures/rigacar/issues"&gt;create an issue&lt;/a&gt;
on GitHub and, of course, you can &lt;a class="reference external" href="https://github.com/digicreatures/rigacar"&gt;fork my code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Originally, I was inspired by &lt;a class="reference external" href="https://blenderartists.org/forum/showthread.php?239360-Car-Rig"&gt;Ondrej Raha's add-on&lt;/a&gt;.
I eventually realized it would not provide the features
I was looking for. So I decided to write my own add-on and finally to share it with the community.
Thanks to him for giving me inspiration.&lt;/p&gt;
&lt;p&gt;Drive safely :)&lt;/p&gt;
&lt;/div&gt;
</content><category term="articles"></category><category term="rigacar"></category><category term="blender"></category><category term="rig"></category><category term="car"></category><category term="animation"></category></entry><entry><title>Baking normal from Cycles material</title><link href="http://digicreatures.net/articles/cycles-normal-baking.html" rel="alternate"></link><published>2017-06-10T12:00:00+02:00</published><updated>2019-03-04T12:00:00+01:00</updated><author><name>David Gayerie</name></author><id>tag:digicreatures.net,2017-06-10:/articles/cycles-normal-baking.html</id><summary type="html">&lt;p class="first last"&gt;a useful node for baking normal correctly&lt;/p&gt;
</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Important update since 2019-03-04&lt;/p&gt;
&lt;p class="last"&gt;&lt;strong&gt;If you use Blender 2.80 or later, you do not need anymore&lt;/strong&gt; the &lt;em&gt;normal to map&lt;/em&gt;
node. Blender 2.80 now takes into account normal information created by your
material when you bake the normals. Thanks to the Blender developers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition admonition-downloadable-file"&gt;
&lt;p class="first admonition-title"&gt;Downloadable file&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://digicreatures.net/resources/normal_to_map.blend"&gt;normal_to_map.blend&lt;/a&gt;&lt;/p&gt;
&lt;p class="last"&gt;This file contains the &lt;em&gt;normal to map&lt;/em&gt; node for Cycles.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;If you have ever tried to bake normals in &lt;a class="reference external" href="http://www.blender.org"&gt;Blender&lt;/a&gt; using Cycles
render engine, you probably noticed the following behavior:
the bake process uses only information from the mesh geometry and ignores normal variations
created by your material. It means that if you use normal map and/or bump map, they are not taken
into account.&lt;/p&gt;
&lt;p&gt;If we think about it, it should not be really surprising: as Cycles is based on a nodal system,
we can create materials with infinite combinations, we can even use one normal map for diffuse shader and another for glossy shader.
It provides complete artistic freedom... but this also means Cycles cannot identify which part of your material is related
to normal computation. So the bake tool has no other option than completely ignores effects created by your material when you choose
&lt;em&gt;normal&lt;/em&gt; as the bake type.&lt;/p&gt;
&lt;p&gt;Too much freedom leads sometime to frustrating limitations! Actually, baking normals including material
effects is really useful for at least two reasons:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;If you use a normal map to catch details from a high resolution model and a bump map to paint additional
details, you probably combine them in your Cycles material. But if you want to export your model
in other render engines, some of them (especially real time renderers) allow to use either normal
map or bump map but not both of them. You shoudn't have to choose between one map or another...&lt;/li&gt;
&lt;li&gt;If you use high resolution textures, it could be interesting to merge information from normal map,
bump map and procedural normal textures into a single normal map to reduce memory footprint and simplify your material.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;The &lt;em&gt;Material Output&lt;/em&gt; node in Cycles has the &lt;em&gt;Displacement&lt;/em&gt; dedicated slot. If you use this slot in your material
it deactivates all &lt;em&gt;Normal&lt;/em&gt; slot from all nodes. But as it also clearly indicates to Cycles how your material
is affecting the geometry, then the effect of the displacement will be included in the bake process.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Even if it is not straighforward, you can actually create normal map including effects from your material
in Cycles. I found several ways to achieve that. All of them, as far as I can judge,
are mathematically correct (otherwise the final normal map would create slightly different effect
than the original material). From my perspective, the most effective way was to create a special
node in Cycles. I called it &lt;em&gt;normal to map&lt;/em&gt;. In this article, I will explain how to use it
and the math foundations behind it.&lt;/p&gt;
&lt;p&gt;If you just want to use the &lt;em&gt;normal to map&lt;/em&gt; node, you can &lt;a class="reference external" href="http://digicreatures.net/resources/normal_to_map.blend"&gt;download the blend file&lt;/a&gt;.
The file contains a very simple example and the node itself.
This file is licensed under &lt;a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/"&gt;CC0 1.0 Universal&lt;/a&gt;
so you can freely use this node for your own purpose.&lt;/p&gt;
&lt;p&gt;For the rest of this article, I assume that you are familiar with Blender, Cycles and the bake tool in Blender.&lt;/p&gt;
&lt;div class="section" id="how-to-use-normal-to-map-node"&gt;
&lt;h2&gt;How to use &lt;em&gt;normal to map&lt;/em&gt; node&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;normal to map&lt;/em&gt; node is designed to be used when you want to bake normal information from your material
in Cycles. So you should add it just before the baking process and remove it from your material afterward.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/material_with_normal_to_map_node.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="Material using the normal to map node" src="http://digicreatures.net/photos/full_normal_baking/material_with_normal_to_map_nodet.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;Material using the &lt;em&gt;normal to map&lt;/em&gt; node&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The input slot &lt;em&gt;Normal&lt;/em&gt; expects the same input as standard BSDF nodes and it is the normal you want to bake.
There are two output slots: &lt;em&gt;sRGB color&lt;/em&gt; and &lt;em&gt;Non-color&lt;/em&gt;. &lt;strong&gt;You must use the same output as the color space of
your baking texture&lt;/strong&gt;. By default, Blender creates a texture in sRGB color space.&lt;/p&gt;
&lt;p&gt;I encourage you to use the &lt;em&gt;Non-Color&lt;/em&gt; format: less computation is required (no gamma correction applied)
so it should avoid some rounding issues during computation. You can change color space of your texture in the
properties panel in the UV/image editor.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/texture_color_space.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="Texture color space in the UV/image editor" src="http://digicreatures.net/photos/full_normal_baking/texture_color_spacet.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;Texture color space in the UV/image editor&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;For people using the Filmic Blender color management, &lt;em&gt;sRGB&lt;/em&gt; is labeled &lt;em&gt;sRGB EOTF&lt;/em&gt; and &lt;em&gt;Non-color&lt;/em&gt; is labeled &lt;em&gt;Non-Colour Data&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Usage of this node follows these steps:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;add the 'normal to map' node to your material&lt;/li&gt;
&lt;li&gt;plug in the normal you want to bake to the input socket&lt;/li&gt;
&lt;li&gt;plug the chosen output slot to an Emission node (ctrl+shift+left click if you use the Node Wrangler addon)&lt;/li&gt;
&lt;li&gt;in the UV/image editor, create a new image&lt;/li&gt;
&lt;li&gt;in the properties panel of the UV/image editor, choose the same color space as the output socket&lt;/li&gt;
&lt;li&gt;add a texture node in your material and select the newly created image&lt;/li&gt;
&lt;li&gt;in the bake tool, select the type 'Emit'&lt;/li&gt;
&lt;li&gt;click the bake button&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/normal_to_map_steps.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="Preview of all necessary steps" src="http://digicreatures.net/photos/full_normal_baking/normal_to_map_stepst.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;Preview of all necessary steps&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The node creates the appropriate colors to represent the normal information. So you must use an emission
shader as if the object would &lt;em&gt;emit&lt;/em&gt; normal information. As pure emission material is not affected by
fireflies and light bouncing, you can use only one sample for rendering. It means that the baking
process is super fast!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance-improvements"&gt;
&lt;h2&gt;Performance improvements&lt;/h2&gt;
&lt;p&gt;Creating one normal texture to replace part of a material can provide interesting improvements.
Consider the images below. For the first one, the material of the body uses a normal map, a bump map
and a procedural texture to generate additional normal variations. For the second one, I baked the normal
from the original material using the &lt;em&gt;Normal to map&lt;/em&gt; node. I saved the result in a file and I created a much
simpler material using the baked normal map.&lt;/p&gt;
&lt;div class="images docutils container"&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/portrait.2000s.16_03.materialbump.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="Using the original material" src="http://digicreatures.net/photos/full_normal_baking/portrait.2000s.16_03.materialbumpt.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;Using the original material&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/portrait.2000s.13_55.usingnormaltomap.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="Using the normal map baked with the Normal to map node" src="http://digicreatures.net/photos/full_normal_baking/portrait.2000s.13_55.usingnormaltomapt.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;Using the normal map baked with the &lt;em&gt;Normal to map&lt;/em&gt; node&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The following table shows some figures about the renderings:&lt;/p&gt;
&lt;table border="1" class="colwidths-given docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="25%" /&gt;
&lt;col width="25%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Material&lt;/th&gt;
&lt;th class="head"&gt;Rendering time&lt;/th&gt;
&lt;th class="head"&gt;Memory peak&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Original material&lt;/td&gt;
&lt;td&gt;16:03&lt;/td&gt;
&lt;td&gt;1371 Mo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Material using baked normal&lt;/td&gt;
&lt;td&gt;13:55&lt;/td&gt;
&lt;td&gt;350 Mo&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For this model, using a simpler material has a real impact on performance!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="known-issues"&gt;
&lt;h2&gt;Known issues&lt;/h2&gt;
&lt;p&gt;Due to internal computation, you can get slight variations of the normal computed by the &lt;em&gt;Normal to map&lt;/em&gt;
node and the original material. As these variations are really subtle there are completely unnoticeable.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Normal to map&lt;/em&gt; node is dramatically affected by rotation and scale of your model. Don't forget
to apply transformations in Blender before baking.&lt;/p&gt;
&lt;p&gt;The most annoying issue does not come from the node itself but from the bake process. If you look closely
at the two images above, they seem to be identical... but they are not! If you open these images into
separate tabs at full size and switch between them, you will notice a weird effect: some details seem to slip
over the surface! Look at the image below to see this effect:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="detail of the slip over effect" src="http://digicreatures.net/images/full_normal_baking/portrait_detail_normal_to_map_variation.gif" /&gt;
&lt;p class="caption"&gt;The &lt;em&gt;slip over&lt;/em&gt; effect between original material and material using the baked texture&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;It took me a day to convince myself this effect was not created by the &lt;em&gt;Normal to map&lt;/em&gt; node!
Actually, the problem comes from the integration of the bump map into a normal map.
To summarize, bump map stores height information while normal map stores variation of height.
It means if a texture contains three pixels to represent a bump map, each pixel represents
a different height. To achieve the same result with a normal map, the texture must contain at
least two pixels to encode the variation of height. But most of all, there is a shift between
the bump map and the normal map.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="shift between bump map and normal map" src="http://digicreatures.net/images/full_normal_baking/bumpmap_vs_normalmap.png" /&gt;
&lt;p class="caption"&gt;Shift between bump map and normal map&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;So when we want to convert directly or indirectly, bump map info into normal map info, we
get a shift of information in the final texture. One way to avoid this is to use a
texture with higher resolution for the final bake. But it is not always desirable.&lt;/p&gt;
&lt;p&gt;So if you plan to use the &lt;em&gt;Normal to map&lt;/em&gt; node be aware of this effect, especially if you
want to create close shot of your model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-normal-to-map-node-works"&gt;
&lt;h2&gt;How &lt;em&gt;normal to map&lt;/em&gt; node works&lt;/h2&gt;
&lt;p&gt;This section covers what happens under the hood. You don't need to understand that part to
use the node. But if you are interested in the math, let's start with normal map.&lt;/p&gt;
&lt;p&gt;Obviously, normal map has nothing to do with color! A normal texture
is an image and we can open it into an image editor. But it is not
really an image because each pixel (or to be precise each texel) is not a
color information: it is a normal information.&lt;/p&gt;
&lt;p&gt;What is a normal? A normal is a vector perpendicular to a surface. Why is it so
important? Because the normal is used to define what is the front of a face
and what is the back. More importantly, the normal is used internally in almost any
shader node. For instance to define how the light bounces over the surface.
If we can cheat and slightly modify the orientation of the normal over the surface
we can change the way the light bounces, create fake bumps and simulate non existing geometry.
This is precisely what normal map is used for.&lt;/p&gt;
&lt;p&gt;Normal texture stores normal variations considering the original normal coordinates are (0,0,1).
It means that the coordinates must be in tangent space. And that's the point:
Cycles provides normal information in world space. In order to bake normal, we
have to transform normal vectors from world space to tangent space.
So, we have to do the following operation:&lt;/p&gt;
&lt;div class="formula"&gt;
&lt;i&gt;N&lt;/i&gt;&lt;sub&gt;&lt;i&gt;ts&lt;/i&gt;&lt;/sub&gt; = &lt;i&gt;M&lt;/i&gt;&lt;i&gt;N&lt;/i&gt;&lt;sub&gt;&lt;i&gt;ws&lt;/i&gt;&lt;/sub&gt;
&lt;/div&gt;
&lt;p&gt;Where &lt;span class="formula"&gt;&lt;i&gt;N&lt;/i&gt;&lt;sub&gt;&lt;i&gt;ws&lt;/i&gt;&lt;/sub&gt;&lt;/span&gt; is the normal vector in world space (the one created by the material),
&lt;span class="formula"&gt;&lt;i&gt;M&lt;/i&gt;&lt;/span&gt; is the tranform matrix from world space to tangent space and &lt;span class="formula"&gt;&lt;i&gt;N&lt;/i&gt;&lt;sub&gt;&lt;i&gt;ts&lt;/i&gt;&lt;/sub&gt;&lt;/span&gt;
is the normal vector in tangent space (the one we want to get).
The tranform matrix &lt;span class="formula"&gt;&lt;i&gt;M&lt;/i&gt;&lt;/span&gt; is a 3x3 matrix composed in line by the tangent vector,
the bitangent vector and the original normal vector of the face:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="transformation matrix" src="http://digicreatures.net/images/full_normal_baking/ws2ts_matrix.png" /&gt;
&lt;/div&gt;
&lt;p&gt;Cycles provides tangent vector and normal vector for the current face. We
can easily compute bitangent vector as the cross product of normal vector and tangent vector.
However, Cycles has no support for matrix operation but we can easily decompose the operations:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="transformation matrix decomposition" src="http://digicreatures.net/images/full_normal_baking/ws2ts_matrix_computation.png" /&gt;
&lt;/div&gt;
&lt;p&gt;and create the node set to do the math:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/normal_to_map_wstots.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="From world space to tangent space in Cycles" src="http://digicreatures.net/photos/full_normal_baking/normal_to_map_wstotst.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;From world space to tangent space in Cycles&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;All this could have been much simpler if the
&lt;a class="reference external" href="https://docs.blender.org/manual/en/dev/render/cycles/nodes/types/vector/transform.html"&gt;Vector Transform&lt;/a&gt;
node accepts tangent space... could be an interesting improvement.&lt;/p&gt;
&lt;p&gt;Then we have to encode vector coordinates into color values to create the final normal
texture. As normal vector is a unit vector x, y and z coordinates are between -1 and 1.
We have to transform these coordinates to color values between 0 and 1. The
&lt;a class="reference external" href="https://docs.blender.org/manual/en/dev/render/cycles/nodes/types/vector/curves.html"&gt;Vector Curves&lt;/a&gt;
node can do the math for us.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;a href="http://digicreatures.net/photos/full_normal_baking/normal_to_map_color_management.jpg" data-lightbox="full_normal_baking"&gt;&lt;img alt="Converting vector to color" src="http://digicreatures.net/photos/full_normal_baking/normal_to_map_color_managementt.jpg" /&gt;&lt;/a&gt;
&lt;p class="caption"&gt;Converting vector to color&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Finally, sRGB color space means that Blender will apply a gamma correction of 1/2.2 because file formats
with 8 bits per channel (PNG, JPEG...) must pre encode color values like this. But as normal texture
does not contain color values but encoded vector coordinates, we must prevent this by applying
the inverse gamma correction of 2.2. Using a non color space for the bake texture is straightforward because
we inform Blender we want to use a linear color space (no gamma correction is needed).&lt;/p&gt;
&lt;/div&gt;
</content><category term="articles"></category><category term="node"></category><category term="normal map"></category><category term="bake"></category></entry></feed>